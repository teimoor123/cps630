<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Battleship Game</title>
  <style>
    #gameContainer {
      position: relative;
      width: 300px;
      height: 900px;
    }
    #gridCanvas1, #gridCanvas2 {
      border: 1px solid black;
    }
  </style>
</head>
<body>
<div id="gameContainer">
  <canvas id="gridCanvas1" width="300" height="400"></canvas>
  <canvas id="gridCanvas2" width="300" height="300"></canvas>
</div>
<script>
  document.addEventListener('DOMContentLoaded', function() {
    const canvas = document.getElementById('gridCanvas1');
    const ctx = canvas.getContext('2d');
    const gridCanvas2 = document.getElementById('gridCanvas2');
    const ctxGrid2 = gridCanvas2.getContext('2d');
    const gridSize = 10;
    const cellSize = canvas.width / gridSize;
    let dragging = false;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let userTurn = true;

    let ships = [
      { ogX: 30, ogY: 305, x: 30, y: 305, width: 30, height: 30, dragging: false, placed: false, size: 1, timesHit: 0 },
      { ogX: 90, ogY: 305, x: 90, y: 305, width: 30, height: 60, dragging: false, placed: false, size: 2, timesHit: 0 },
      { ogX: 150, ogY: 305, x: 150, y: 305, width: 30, height: 90, dragging: false, placed: false, size: 3, timesHit: 0 }
    ];
    let enemyShips = [[3, 7], [1, 1], [2, 1], [5, 5], [5, 6], [5, 7]];
    let hits = [];
    let enemyHits = [];

    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height); 
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          ctx.strokeRect(i * cellSize, j * cellSize, cellSize, cellSize);
        }
      }
      ctxGrid2.clearRect(0, 0, canvas.width, canvas.height); 
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          ctxGrid2.strokeRect(i * cellSize, j * cellSize, cellSize, cellSize);
        }
      }
    }

    function drawShips() {
      ships.forEach(ship => {
        ctx.fillStyle = 'blue';
        ctx.fillRect(ship.x, ship.y, ship.width, ship.height);
      });
    }

    function drawGame() {
      drawGrid(); 
      drawShips();
    }

    canvas.addEventListener('mousedown', function(event) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;

      ships.forEach((ship, index) => {
        if (!ship.placed && mouseX > ship.x && mouseX < ship.x + ship.width && mouseY > ship.y && mouseY < ship.y + ship.height) {
          dragging = true;
          dragOffsetX = mouseX - ship.x;
          dragOffsetY = mouseY - ship.y;
          ships[index].dragging = true;
        }
      });
    });

    window.addEventListener('mousemove', function(event) {
      if (dragging) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left - dragOffsetX;
        const mouseY = event.clientY - rect.top - dragOffsetY;
        
        ships.forEach((ship, index) => {
          if (ship.dragging) {
            ships[index].x = mouseX;
            ships[index].y = mouseY;
          }
        });

        drawGame();
      }
    });

    window.addEventListener('mouseup', function() {
      if (dragging) {
        dragging = false;
        ships.forEach((ship, index) => {
          if (ship.dragging) {
            let snappedX = Math.round(ship.x / cellSize) * cellSize;
            let snappedY = Math.round(ship.y / cellSize) * cellSize;
            if (index == 0) {
              if (snappedX < 0) {
                snappedX = 0;
              } else if (snappedX > 270) {
                snappedX = 270;
              }
              if (snappedY < 0) {
                snappedY = 0;
              } else if (snappedY > 270) {
                snappedY = 270;
              }
            } else if (index == 1) {
              if (snappedX < 0) {
                snappedX = 0;
              } else if (snappedX > 270) {
                snappedX = 270;
              }
              if (snappedY < 0) {
                snappedY = 0;
              } else if (snappedY > 240) {
                snappedY = 240;
              }
            } else {
              if (snappedX < 0) {
                snappedX = 0;
              } else if (snappedX > 270) {
                snappedX = 270;
              }
              if (snappedY < 0) {
                snappedY = 0;
              } else if (snappedY > 210) {
                snappedY = 210;
              }
            }
            let overlap = ships.some((otherShip, otherIndex) => {
              if (index !== otherIndex) {
                return !(snappedX + ship.width <= otherShip.x || 
                         snappedX >= otherShip.x + otherShip.width ||
                         snappedY + ship.height <= otherShip.y || 
                         snappedY >= otherShip.y + otherShip.height);
              }
              return false;
            });

            if (!overlap) {
              ship.x = snappedX;
              ship.y = snappedY;
              ship.placed = true;
              ship.dragging = false;
            } else {
              ship.x = ship.ogX;
              ship.y = ship.ogY;
              ship.dragging = false;
            }
          }
        });
        drawGame();
      }
    });
    
    function computerTurn() {
      let hitMade = false;
      while (!hitMade) {
        let x = Math.floor(Math.random() * gridSize);
        let y = Math.floor(Math.random() * gridSize);
        if (!enemyHits.some(hit => hit[0] === x && hit[1] === y)) {
          let isHit = ships.some(ship => {
            let hitOnShip = x >= ship.x / cellSize && x < (ship.x + ship.width) / cellSize &&
                            y >= ship.y / cellSize && y < (ship.y + ship.height) / cellSize;
            if (hitOnShip) {
              ship.timesHit += 1;
            }
            return hitOnShip;
          });
          enemyHits.push([x, y]);
          if (isHit) {
            ctx.fillStyle = 'orange';
            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
          } else {
            ctx.fillStyle = 'green';
            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
          }
          
		  ships.forEach(ship => {
            if (ship.size <= ship.timesHit) {
              ctx.fillStyle = 'red';
              ctx.fillRect(ship.x, ship.y, ship.width, ship.height);
            }
          });
          

          hitMade = true;
        }
      }
      userTurn = true;
    }

    function handleCanvasClick(event) {
      if (!userTurn) return;
      const rect = gridCanvas2.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const gridX = Math.floor(x / cellSize);
      const gridY = Math.floor(y / cellSize);
	  if (ships.every(ship => ship.placed == true)) {
        if (!hits.some(hit => hit[0] === gridX && hit[1] === gridY)) {
          if (enemyShips.some(ship => ship[0] === gridX && ship[1] === gridY)) {
            ctxGrid2.fillStyle = 'orange';
            ctxGrid2.fillRect(gridX * cellSize, gridY * cellSize, cellSize, cellSize);
            hits.push([gridX, gridY]);
          } else {
            ctxGrid2.fillStyle = 'blue';
            ctxGrid2.fillRect(gridX * cellSize, gridY * cellSize, cellSize, cellSize);
            hits.push([gridX, gridY]);
          }
          if (hits.some(hit => hit[0] === 5 && hit[1] === 5)) {
            if (hits.some(hit => hit[0] === 5 && hit[1] === 6)) {
              if (hits.some(hit => hit[0] === 5 && hit[1] === 7)) {
                ctxGrid2.fillStyle = 'red';
                ctxGrid2.fillRect(150, 150, cellSize, 3 * cellSize);
              }
            }
          }
          if (hits.some(hit => hit[0] === 1 && hit[1] === 1)) {
            if (hits.some(hit => hit[0] === 2 && hit[1] === 1)) {
              ctxGrid2.fillStyle = 'red';
              ctxGrid2.fillRect(30, 30, 2 * cellSize, cellSize);
            }
          }
          if (hits.some(hit => hit[0] === 3 && hit[1] === 7)) {
            ctxGrid2.fillStyle = 'red';
            ctxGrid2.fillRect(90, 210, cellSize, cellSize);
          }
          userTurn = false;
          computerTurn();
          
        }
      }
    }
    
    drawGame();
    gridCanvas2.addEventListener('click', handleCanvasClick);
  });
</script>
</body>
</html>
