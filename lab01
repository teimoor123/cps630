<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Battleship Game</title>
  <style>
    #gameContainer {
      position: relative;
      width: 300px;
      height: 900px;
    }
    #gridCanvas1, #gridCanvas2 {
      border: 1px solid black;
    }
  </style>
</head>
<body>
<div id="gameContainer">
  <canvas id="gridCanvas1" width="300" height="400"></canvas>
  <canvas id="gridCanvas2" width="300" height="300"></canvas>
</div>
<script>
  document.addEventListener('DOMContentLoaded', function() {
    const canvas = document.getElementById('gridCanvas1');
    const ctx = canvas.getContext('2d');
    const gridCanvas2 = document.getElementById('gridCanvas2');
    const ctxGrid2 = gridCanvas2.getContext('2d');
    const gridSize = 10;
    const cellSize = canvas.width / gridSize;
    let dragging = false;
    let dragOffsetX = 0;
    let dragOffsetY = 0;

    let ships = [
      { ogX: 30, ogY: 305, x: 30, y: 305, width: 30, height: 30, dragging: false, placed: false },
      { ogX: 90, ogY: 305, x: 90, y: 305, width: 30, height: 60, dragging: false, placed: false },
      { ogX: 150, ogY: 305, x: 150, y: 305, width: 30, height: 90, dragging: false, placed: false }
    ];
    let ships2 = [[5, 5], [5, 6], [5, 7]];
    let hits = [];

    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height); 
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          ctx.strokeRect(i * cellSize, j * cellSize, cellSize, cellSize);
        }
      }
      ctxGrid2.clearRect(0, 0, canvas.width, canvas.height); 
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          ctxGrid2.strokeRect(i * cellSize, j * cellSize, cellSize, cellSize);
        }
      }
    }

    function drawShips() {
      ships.forEach(ship => {
        ctx.fillStyle = 'blue';
        ctx.fillRect(ship.x, ship.y, ship.width, ship.height);
      });
    }

    function drawGame() {
      drawGrid(); 
      drawShips();
    }

    canvas.addEventListener('mousedown', function(event) {
      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;

      ships.forEach((ship, index) => {
        if (!ship.placed && mouseX > ship.x && mouseX < ship.x + ship.width && mouseY > ship.y && mouseY < ship.y + ship.height) {
          dragging = true;
          dragOffsetX = mouseX - ship.x;
          dragOffsetY = mouseY - ship.y;
          ships[index].dragging = true;
        }
      });
    });

    window.addEventListener('mousemove', function(event) {
      if (dragging) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left - dragOffsetX;
        const mouseY = event.clientY - rect.top - dragOffsetY;
        
        ships.forEach((ship, index) => {
          if (ship.dragging) {
            ships[index].x = mouseX;
            ships[index].y = mouseY;
          }
        });

        drawGame();
      }
    });

    window.addEventListener('mouseup', function() {
      if (dragging) {
        dragging = false;
        ships.forEach((ship, index) => {
          if (ship.dragging) {
            let snappedX = Math.round(ship.x / cellSize) * cellSize;
            let snappedY = Math.round(ship.y / cellSize) * cellSize;
            if (index == 0) {
              if (snappedX < 0) {
                snappedX = 0;
              } else if (snappedX > 270) {
                snappedX = 270;
              }
              if (snappedY < 0) {
                snappedY = 0;
              } else if (snappedY > 270) {
                snappedY = 270;
              }
            } else if (index == 1) {
              if (snappedX < 0) {
                snappedX = 0;
              } else if (snappedX > 270) {
                snappedX = 270;
              }
              if (snappedY < 0) {
                snappedY = 0;
              } else if (snappedY > 240) {
                snappedY = 240;
              }
            } else {
              if (snappedX < 0) {
                snappedX = 0;
              } else if (snappedX > 270) {
                snappedX = 270;
              }
              if (snappedY < 0) {
                snappedY = 0;
              } else if (snappedY > 210) {
                snappedY = 210;
              }
            }
            let overlap = ships.some((otherShip, otherIndex) => {
              if (index !== otherIndex) {
                return !(snappedX + ship.width <= otherShip.x || 
                         snappedX >= otherShip.x + otherShip.width ||
                         snappedY + ship.height <= otherShip.y || 
                         snappedY >= otherShip.y + otherShip.height);
              }
              return false;
            });

            if (!overlap) {
              ship.x = snappedX;
              ship.y = snappedY;
              ship.placed = true;
              ship.dragging = false;
            } else {
              ship.x = ship.ogX;
              ship.y = ship.ogY;
              ship.dragging = false;
            }
          }
        });
        drawGame();
      }
    });

    function handleCanvasClick(event) {
      const rect = gridCanvas2.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      const gridX = Math.floor(x / cellSize);
      const gridY = Math.floor(y / cellSize);

      if (!hits.some(hit => hit[0] === gridX && hit[1] === gridY)) {
        if (ships2.some(ship => ship[0] === gridX && ship[1] === gridY)) {
          ctxGrid2.fillStyle = 'red';
          ctxGrid2.fillRect(gridX * cellSize, gridY * cellSize, cellSize, cellSize);
          hits.push([gridX, gridY]);
        } else {
          ctxGrid2.fillStyle = 'blue';
          ctxGrid2.fillRect(gridX * cellSize, gridY * cellSize, cellSize, cellSize);
          hits.push([gridX, gridY]);
        }
      }
    }
    
    drawGame();
    gridCanvas2.addEventListener('click', handleCanvasClick);
  });
</script>
</body>
</html>
